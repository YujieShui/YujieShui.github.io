---
title: JVM-双亲委派模型
toc: true
categories:
  - Java
  - JVM
tags:
  - java
  - jvm
abbrlink: 5b2f68e0
date: 2019-09-11 23:02:35
---

本文介绍 Java 中的类加载器，以及双亲委派机制。

 Java 中的类加载器包括：启动类加载器，扩展类加载器，应用程序类加载器，自定义类加载器。

<!-- more -->

# 启动类加载器

启动类加载器(Bootstrap ClassLoader)，主要负责加载Java目录下的核心类，即 Java 安装目录下的 lib 目录，其中就包含 Java 最核心的一类类库。

JVM一旦启动会首先依托启动类加载器，去加载`${JAVA_HOME}/lib`中的核心类库。

# 扩展类加载器

扩展类加载器(Extension ClassLoader)，它将会加载 `${JAVA_HOME}/lib/ext` 目录中的类。

# 应用程序类加载器

应该程序类加载器Application ClassLoader，负责去加载“ClassPath”环境变量所指定的路径中的类。

可以将其理解为我们写好的 Java 代码，应用程序类加载器负责将我们写的Java代码加载到内存中。

# 自定义类加载器

自定义类加载器，可以根据自己的需求加载类。

# 双亲委派机制

![双亲委派机制](http://image.shuiyujie.com/2019-09-11-23-32-24.png)

JVM类加载器具有如上所示的亲子层级结构，启动加载器在第一层，扩展加载器在第二层，应用类加载器在第三层，自定义类加载器在最后一层。

基于该亲子层级结构，就有一个**双亲委派机制**，具体来说是怎么样的呢？

具体来说，现在有一个`Manager`类，它是我们自己写的Java代码，需要使用*应用程序类加载器*来加载。

此时，应该程序类加载器会先问它的上一级*扩展类加载器*，你能加载到这个类么？然后扩展类加载器继续问它的上一级*启动类加载器*，你能加载到这个类么？

启动类加载器在`${JAVA_HOME}/lib`下找不到`Manage`这个类，就告诉扩展类加载器，我加载不到，你自己找去。扩展类加载器在 `${JAVA_HOME}/lib/ext` 下也没有找到这个类，叫告诉应用程序类加载器自己去加载这个类。

终于，应该用程序类加载器在自己负责的范围内，比如说我们打成的 jar 包中，找到了这个类，就将其加载到内存中。

总的来说，**双亲委派模型**就是：先找父亲去加载，父亲加载不到再由儿子来加载。这样的话，可以避免多层级的加载器结构重复加载某些类。