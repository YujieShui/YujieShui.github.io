---
title: JVM-垃圾回收算法与垃圾回收器
toc: true
categories:
  - Java
  - JVM
tags:
  - java
  - jvm
abbrlink: e2ebbcff
date: 2019-09-14 10:06:20
---

本文记录一些垃圾回收算法和垃圾回收器。

<!-- more -->

# 复制算法



# Serial垃圾回收器

![单线程执行垃圾回收算法](http://image.shuiyujie.com/2019-09-14-10-14-52.png)

Serial 垃圾回收器用于新生代的垃圾回收。无论服务器是几核的，都只用单线程执行垃圾回收算法。

# ParNew 垃圾回收器

![多线程执行垃圾回收算法](http://image.shuiyujie.com/2019-09-14-10-15-37.png)

ParNew 垃圾回收器用于新生代的垃圾回收。ParNew 垃圾回收器可以使用多个垃圾回收线程来执行垃圾回收算法。在启动系统时，可以使用 `-XX:+UseParNewGC` 参数来指定使用 ParNew 垃圾回收器。

ParNew 垃圾回收器默认使用的线程数量与机器的核数相同，比如我们线上机器假设用的是4核CPU，那默认就会使用 4 个线程。

线程数也可以通过 `-XX:ParallelGCThreads` 手动指定，但是不建议修改。

# 选择单线程还是选择多线程？

- 到底是用单线程垃圾回收好，还是多线程垃圾回收好？
- 到底是Serial垃圾回收器好还是ParNew垃圾回收器好？

启动系统的时候是可以区分服务器模式和客户端模式的，如果你启动系统的时候加入 `-server` 就是服务器模式，如果加入 `-cilent` 就是客户端模式。

如果部署的是网站系统、业务系统等大型系统，一般都是多核 CPU。此时使用多线程，使用 ParNew 垃圾回收器更好。

如果是 Windows 客户端程序，如果是单核 CPU 使用 ParNew 垃圾回收器就会在一个 CPU 上启动多个垃圾回收线程，会有上下文切换的开销，反而不如单线程 Serial 垃圾回收器效率高。

# 标记清理算法

老年代一般选择的垃圾回收器是 CMS，采用标记清理算法。简单来说，标记清理算法分成两步：标记出哪些对象是垃圾对象，再一次性把这些对象清理掉。

举例来说，当程序触发了**Full GC** 回收老年代的垃圾对象。

- 先通过追踪 GC Roots 的方法，看老年代中的各个对象是不是被 GC Roots 引用，如果被引用就是存活对象，否则就是垃圾对象。这些垃圾对象就会被**标记**出来。
- 然后再一次性清理被标记出来的**垃圾对象**。

但是由于 Full GC 的时间比 Minor GC 的时间差不多长 10 倍，如果和 Minor GC 一样，Full GC 采用先 Stop the World 再用标记清理算法回收垃圾，就会导致系统卡死时间过长，很多响应无法处理。

所以 CMS 让系统一边工作，一边进行垃圾回收。CMS 垃圾回收的过程一共分为 4 个阶段：

1. **初始标记**。Stop the World 停止所有工作线程，仅标记 GC Roots 直接引用的对象。这一步速度很快。
2. **并发标记**。此时允许系统线程创建对象，继续运行。垃圾回收线程则会追踪老年代中的对象是否从根源上被 GC Roots 引用。这一步是最耗时的，但是和系统程序并发运行，不会对系统运行造成影响。
3. **重新标记**。Stop the World 重新标记在第二阶段里新创建的对象，以及原本被引用现在失去引用的对象。由于支队第二阶段有变动的对象进行标记，速度也比较快。
4. **并发清理**。系统随意运行，同时清理之前被标记为垃圾的对象。这个阶段很耗时，但是由于和系统程序并发运行，并不影响系统程序的运行。

# CMS 垃圾回收器



# Serial Old 垃圾回收器

在并发清理期间，系统程序可能将某些对象分配在新生代，然后触发了一次 Minor GC，一些对象进入了老年代，但是短时间内又没有人引用它们。这些对象就被称为**浮动垃圾**。

浮动垃圾意味着虽然他们是垃圾，但是 CMS 在并发清理阶段只会清理这一次 Full GC 被标记出来的垃圾，这些浮动垃圾只有等到下一次 GC 的时候才会回收它们。

为了保证在 CMS 并发清理期间，还有一定的内存空间让一些对象可以进入老年代，一般会预留一些空间。CMS垃圾回收的触发时机，其中有一个就是当老年代内存占用达到一定比例了，就自动执行GC。 `-XX:CMSInitiatingOccupancyFaction` 参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK 1.6里面默认的值是92%。

也就是说，老年代占用了92%空间了，就自动进行CMS垃圾回收，预留8%的空间给并发回收期间，系统程序把一些新对象放入老年代中。

**那么如果CMS垃圾回收期间，系统程序要放入老年代的对象大于了可用内存空间，此时会如何？**

这个时候，会发生 Concurrent Mode Failure，就是说并发垃圾回收失败了，我一边回收，你一边把对象放入老年代，内存都不够了。

此时就会自动用**Serial Old垃圾回收器**替代CMS，就是直接强行把系统程序 Stop the World，重新进行长时间的GC Roots追踪，标记出来全部垃圾对象，不允许新的对象产生。然后一次性把垃圾对象都回收掉，完事儿了再恢复系统线程。

所以在生产实践中，这个自动触发CMS垃圾回收的比例需要合理优化一下，避免“Concurrent Mode Failure”问题

# G1 垃圾回收器

ParNew 和 CMS 两个垃圾回收器分别来回收新生代和老年代的垃圾对象，有一个最大的痛点就是 **Stop the World**。后面对于垃圾回收器的优化都是朝着减少 Stop the World 的目标去的。

在这基础上 **G1 垃圾回收器**应用而生，它可以提供比 ParNew + CMS 组合更好的垃圾回收性能。

主要设计思想：G1 将内存拆分成一个个小的 **Regin**，新生代和老生代各自对应一些 Regin，回收的时候间可能挑选停顿时间最短，回收对象最多的 Regin，尽量控制**垃圾回收导致的系统停顿时间**小于我们的预设值。

## Regin

G1 垃圾回收器只有逻辑上的新生代和老年代的概念，它会将 Java 堆内存划分成一个个相同大小的 Regin，如下图所示：

![G1 垃圾回收器](http://image.shuiyujie.com/2019-09-14-16-08-34.png)

G1 垃圾回收器中的 Regin 是不区分新生代和老年的，刚开始 Regin 可能不属于任何一个年代，每一个 Regin 这一刻保存新生代对象，下一刻可能就保存老年代对象了。所以也就没有给新生代或者老年代分配多少内存这一说。

## 预期停顿时间

G1另一个特点是可以让我们**设置一个垃圾回收的预期停顿时间**。我们可以指定一段时间内我们希望垃圾回收导致的系统停顿时间不能超过多久，后面的事情就由 G1 全权负责了。







