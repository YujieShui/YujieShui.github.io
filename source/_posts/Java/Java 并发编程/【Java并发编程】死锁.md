---
title: 【Java并发编程】死锁
toc: true
categories:
- Java
- Java并发编程
tags:
  - java
  - 并发编程
abbrlink: 3d624a82
date: 2019-09-07 22:57:54
---

![题图:https://unsplash.com/photos/FjRNGCLnmV0](http://image.shuiyujie.com/martha-dominguez-de-gouveia-FjRNGCLnmV0-unsplash.jpg)

我们来想象一个场景。现在你是清朝末年账房里的一个先生，张三要给李四转4两银子，你从柜台取过张三的账本，发现李四的账本不在了，于是你想先留着张三的账本，等会儿再去柜台看看李四的账本别人用完没。

没成想，李四想着给张三转5两银子，另一个账房先生和你同时取了李四的账本。你俩想法一样，他留着李四的账本，等着一会儿去拿张三的账本。

现在的局面正是俩人互相「死等」对方的账本，在代码的世界，这种局面就叫做「死锁」。死锁用书面点的方法来说就是：**一组互相竞争的线程互相等待，导致「永久」阻塞的现象。**

<!-- more -->

# 死锁的局面

我们现在设法用代买来描述「死锁」的局面。

```java
public class Account {
    private int balance;

    // 转账
    void transfer(Account target, int amt){

        // 锁定转出账户
        synchronized (this){
            // 锁定转入账户
            synchronized (target){
                if(this.balance > amt){
                    this.balance -= amt;
                    target.balance += amt;
                }
            }
        }

    }
}
```

我们现在有一个账户类 Account，`transfer()`是一个转账的方法，它将当前对象的钱转到目标账户中。为了保证`transfer()`能够并发执行而不出现问题，我们给采用**细粒度锁**，即对资源`this`和`target`分别加上了锁，情况如下图所示：

![死锁的局面](http://image.shuiyujie.com/2019-09-07-23-17-54.png)

当线程 T1 指向由账户 A 向账户 B 转账的操作，线程 T2 指向由账户 B 向账户 A 转账的操作。线程 T1 和 T2 同时执行到`synchronized (this)`，分别锁定了账户 A 和账户 B。当它们继续向下执行到`synchronized (target)`时会发现它们互相无法取得自己需要的锁，因为锁已经被对方持有，这就造成了**「死锁的局面」**。

# 死锁产生的 4 中条件及解决办法

并发程序一旦死锁，我们一般只能重启程序。所以没有很好的办法直接解决死锁，我们能做的是**规避死锁**，也就是避免死锁产生的条件，有个叫 Coffman 的牛人已经总结过了，只有以下这四个条件都发生时才会出现死锁：

| 产生条件                                                     | 解决办法                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1. 互斥，共享资源 X 和 Y 只能被一个线程占用                  | 用锁就是为了互斥，所以不会破坏这个条件                       |
| 2. 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X； | 一次性申请所有资源                                           |
| 3. 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；        | 线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源 |
| 4. 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源 | 按序申请资源                                                 |

具体来说一下解决方案：

1. 一次申请所有资源。用一个 List 保存所有被占用的资源，并用`apply()`和`free()`方法来维护这个 List。每次调用`transfer()`时，循环等待所有资源都不在 List 中，并一次申请所有资源。
2. 主动释放资源。`synchronized`采用阻塞等待的方式申请资源，如果想实现主动释放资源可以使用`java.util.concurrent` 这个包 下面提供的`Lock`
3. 按序申请。Accout 类中维护一个变量叫 id，每个对象都有自己的 id 序号。每次申请资源都比较两个对象的 id 大小，每次申请资源时，按照先大后小，或者先小后大的固定顺序。这样就保证先申请资源 A，再申请资源 B，不会出现先申请资源 B 再申请资源 A 的情况发生。