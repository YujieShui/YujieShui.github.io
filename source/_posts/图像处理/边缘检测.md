---
title: 图像处理——边缘检测
toc: true
categories: 图像处理
tags:
  - 图像处理
  - opencv
abbrlink: 1d0f563b
date: 2019-06-02 19:08:59
---

![边缘检测](http://image.shuiyujie.com/2019-06-03-00-12-54.png)

边缘检测是为了识别物体的边缘，而边缘是由数字图像中亮度变化明显的点连接而成的，主要可以通过基于图像强度的一阶和二阶导数来寻找到这些点。

边缘检测可以分成三个步骤：

1. 滤波。由于导数对噪声敏感，所以在边缘检测之前可以先试着[降低图片的噪声](https://shuiyujie.com/post/d966aba8.html)，常用的是高斯滤波。
2. 增强。增强算法可以将图像灰度点邻域强度值有显著变化的点凸显出来，可以通过计算梯度幅值来确定。
3. 检测。根据梯度幅值就可以检测出物体的边缘，由于经过图像增强，有些店并不是要找的边缘值，我们还可以通过阈值化的方式来筛选。

<!-- more -->

# canny

> [Canny边缘检测算子](https://zh.wikipedia.org/wiki/Canny%E7%AE%97%E5%AD%90)是澳洲计算机科学家[约翰·坎尼](https://zh.wikipedia.org/w/index.php?title=%E7%B4%84%E7%BF%B0%C2%B7%E5%9D%8E%E5%B0%BC&action=edit&redlink=1)（John F. Canny）于1986年开发出来的一个多级[边缘检测](https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B)[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95)。更为重要的是Canny创立了“边缘检测计算理论”（computational theory of edge detection）解释这项技术如何工作。
>
> Canny的目标是找到一个最优的边缘检测算法，最优边缘检测的含义是：
>
> - *好的检测* - 算法能够尽可能多地标识出图像中的实际边缘。
> - *好的定位* - 标识出的边缘要与实际图像中的实际边缘尽可能接近。
> - *最小响应* - 图像中的边缘只能标识一次，并且可能存在的图像噪声不应标识为边缘。
>
> 为了满足这些要求Canny使用了[变分法](https://zh.wikipedia.org/wiki/%E5%8F%98%E5%88%86%E6%B3%95)，这是一种寻找满足特定[功能](https://zh.wikipedia.org/wiki/%E5%8A%9F%E8%83%BD)的[函数](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0)的方法。最优检测使用四个[指数函数](https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0)项的和表示，但是它非常近似于[高斯函数](https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E5%87%BD%E6%95%B0)的一阶[导数](https://zh.wikipedia.org/wiki/%E5%AF%BC%E6%95%B0)。
>
> —— 维基百科

我们可以使用 OpenCV 中的 [Canny()](https://docs.opencv.org/3.1.0/da/d22/tutorial_py_canny.html) 来做边缘检测。

```c++
void cv::Canny	(	InputArray 	image,
					OutputArray 	edges,
					double 	threshold1,
					double 	threshold2,
					int 	apertureSize = 3,
					bool 	L2gradient = false 
)	
```

- src: 源图像，8位即可
- edges: 输出的边缘图，要求与源图像保持一样的尺寸和类型
- threshold1: 第一个滞后性阈值
- threshold2: 第二个滞后性阈值
- apertureSize: 表示应该用 Sobel 算子的空间大小，默认为 3
- L2gradient: 计算图像梯度幅值的标识，默认为 false

*注：threshold1 和 threshold2 中较小的用于边缘连接，交大的用来控制强边缘的初始段，推荐的高低阈值比在 2:1 到 3:1 之间。*

```c++
#include <iostream>
#include "opencv2/highgui.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"

int main()
{
    cv::Mat src = cv::imread("../images/persimmon.jpg", cv::IMREAD_COLOR);

    cv::Mat dst, edge, gray;

    // 【1】创建与src同类型和大小的矩阵(dst)
    dst.create(src.size(), src.type());

    // 【2】将原图像转换为灰度图像
    cv::cvtColor(src, gray, cv::COLOR_BGR2GRAY);

    // 【3】运行Canny算子
    cv::Canny(gray, edge, 150, 50, 3);

    // 【4】显示效果图
    cv::namedWindow("【原图】边缘检测", cv::WINDOW_NORMAL);
    cv::namedWindow("【效果图】Canny边缘检测", cv::WINDOW_NORMAL);

    imshow("【原图】边缘检测", gray);
    imshow("【效果图】Canny边缘检测", edge);

    cv::waitKey(0);
}
```



# sobel

> [索伯算子(Sobel operator)](https://zh.wikipedia.org/wiki/%E7%B4%A2%E8%B2%9D%E7%88%BE%E7%AE%97%E5%AD%90) 是[图像处理](https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86)中的[算子](https://zh.wikipedia.org/wiki/%E7%AE%97%E5%AD%90)之一，有时又称为**索伯-费德曼算子**或**索贝滤波器**，在[影像处理](https://zh.wikipedia.org/wiki/%E5%BD%B1%E5%83%8F%E8%99%95%E7%90%86)及[电脑视觉领域](https://zh.wikipedia.org/w/index.php?title=%E9%9B%BB%E8%85%A6%E8%A6%96%E8%A6%BA%E9%A0%98%E5%9F%9F&action=edit&redlink=1)中常被用来做[边缘检测](https://zh.wikipedia.org/wiki/%E9%82%8A%E7%B7%A3%E6%AA%A2%E6%B8%AC)。索伯算子最早是由美国计算机科学家[艾尔文·索伯](https://zh.wikipedia.org/w/index.php?title=%E8%89%BE%E7%88%BE%E6%96%87%C2%B7%E7%B4%A2%E4%BC%AF&action=edit&redlink=1)（Irwin Sobel）及[盖瑞·费德曼](https://zh.wikipedia.org/w/index.php?title=%E8%93%8B%E7%91%9E%C2%B7%E8%B2%BB%E5%BE%B7%E6%9B%BC&action=edit&redlink=1)（Gary Feldman）于1968年在[史丹佛大学](https://zh.wikipedia.org/wiki/%E5%8F%B2%E4%B8%B9%E4%BD%9B%E5%A4%A7%E5%AD%B8)的人工智能实验室(SAIL)所提出，因此为了表扬他们的贡献，才用他们的名字命名。在技术上，它是一离散性[差分](https://zh.wikipedia.org/wiki/%E5%B7%AE%E5%88%86)算子，用来运算图像亮度函数的梯度之近似值。在图像的任何一点使用此算子，索伯算子的运算将会产生对应的梯度向量或是其范数。概念上，索伯算子就是一个小且是整数的滤波器对整张影像在水平及垂直方向上做卷积，因此它所需的运算资源相对较少，另一方面，对于影像中的频率变化较高的地方，它所得的梯度之近似值也比较粗糙。
>
> —— 维基百科

[Sobel 函数](https://docs.opencv.org/3.4.0/d2/d2c/tutorial_sobel_derivatives.html)使用扩展的 Sobel 算子来计算一阶、二阶、三阶或者混合图像的差分，来看一下 OpenCV 中的 Sobel()。

```c++
void cv::Sobel	(	InputArray 	src,
					OutputArray 	dst,
					int 	ddepth,
					int 	dx,
					int 	dy,
					int 	ksize = 3,
					double 	scale = 1,
					double 	delta = 0,
					int 	borderType = BORDER_DEFAULT 
)	
```

- src: 源图像，Mat 类型
- dst: 输出图像，尺寸和类型需要与 src 相同
- ddepth: 输出图像深度，支持如下 src.depth() 和 ddepth 的组合
- dx:  x 方向上的差分阶数
- dy: y 方向上的差分阶数
- ksize: Sobel 卷积核的代销，默认值为 3，必须取 1、3、5 或 7
- scale: 计算导数值时可选的缩放因子，默认值是 1，表示默认情况下是没有应用缩放的，更多可以查看文档
- delta: 表示结果存入输出图像之前可选的 delta 值，默认为 0
- borderType: 推断图像外包部像素的某种边界模式，一般用默认的即可

注：

1. 当内核大小为 3 时，Sobel 内核可能产生比较明显的误差。为此 OpenCV 提供了结果更加精确的 [Scharr()](https://docs.opencv.org/3.4.0/d4/d86/group__imgproc__filter.html#gaa13106761eedf14798f37aa2d60404c9) ，它仅作用于大小为 3 的卷积核，运行速度与 Sobel() 一样快，当结果更精确。
2. 计算图像 X 方向导数是可以取 `xorder = 1, uorder = 0, ksize = 3`
3. 计算图像 Y 方向导数是可以取 `xorder = 0, uorder = 1, ksize = 3`

```c++
//---------------【边缘检测】----------------
// 描述：sobel 函数用法示例
//------------------------------------------

#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>

using namespace cv;

int main()
{
    //【0】创建 grad_x 和 grad_y 矩阵
	Mat grad_x, grad_y;
	Mat abs_grad_x, abs_grad_y,dst;

	//【1】载入原始图  
	Mat src = imread("images/2.jpg");  //工程目录下应该有一张名为1.jpg的素材图

	//【2】显示原始图 
	imshow("【原始图】sobel边缘检测", src); 

	//【3】求 X方向梯度
	Sobel( src, grad_x, CV_16S, 1, 0, 3, 1, 1, BORDER_DEFAULT );
	convertScaleAbs( grad_x, abs_grad_x );
	imshow("【效果图】 X方向Sobel", abs_grad_x); 

	//【4】求Y方向梯度
	Sobel( src, grad_y, CV_16S, 0, 1, 3, 1, 1, BORDER_DEFAULT );
	convertScaleAbs( grad_y, abs_grad_y );
	imshow("【效果图】Y方向Sobel", abs_grad_y); 

	//【5】合并梯度(近似)
	addWeighted( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, dst );
	imshow("【效果图】整体方向Sobel", dst); 

	waitKey(0); 
	return 0; 
}
```



# Laplacian

> 在[数学](https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8)以及[物理](https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86)中，**拉普拉斯算子**或是**拉普拉斯算符**（英语：**Laplace operator, Laplacian**）是由[欧几里得空间](https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%A9%BA%E9%97%B4)中的一个函数的[梯度](https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6)的[散度](https://zh.wikipedia.org/wiki/%E6%95%A3%E5%BA%A6)给出的[微分算子](https://zh.wikipedia.org/wiki/%E5%BE%AE%E5%88%86%E7%AE%97%E5%AD%90)，通常写成 ![\Delta ](https://wikimedia.org/api/rest_v1/media/math/render/svg/32769037c408874e1890f77554c65f39c523ebe2)、![{\displaystyle \nabla ^{2}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f4be87ad083e5ead48d92b0c82f2d4e719cb34a6) 或![{\displaystyle \nabla \cdot \nabla }](https://wikimedia.org/api/rest_v1/media/math/render/svg/9464c9bf2670581ed86a15bc9c2e8ac4b6ab1484)。
>
> 这名字是为了纪念[法国](https://zh.wikipedia.org/wiki/%E6%B3%95%E5%9B%BD)数学家[皮埃尔-西蒙·拉普拉斯](https://zh.wikipedia.org/wiki/%E7%9A%AE%E8%80%B6-%E8%A5%BF%E8%92%99%C2%B7%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF)（1749–1827）而命名的。他在研究[天体力学](https://zh.wikipedia.org/wiki/%E5%A4%A9%E4%BD%93%E5%8A%9B%E5%AD%A6)在数学中首次应用[算子](https://zh.wikipedia.org/wiki/%E7%AE%97%E5%AD%90)，当它被施加到一个给定的[重力位](https://zh.wikipedia.org/wiki/%E9%87%8D%E5%8A%9B%E4%BD%8D)（Gravitational potential）的时候，其中所述算子给出的质量密度的常数倍。经拉普拉斯算子运算为零∆f=0的[函数](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8)称为[调和函数](https://zh.wikipedia.org/wiki/%E8%B0%83%E5%92%8C%E5%87%BD%E6%95%B0)，现在称为[拉普拉斯方程](https://zh.wikipedia.org/wiki/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E7%A8%8B)，和代表了在自由空间中的可能的重力场。
>
> 拉普拉斯算子有许多用途，此外也是[椭圆算子](https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E7%AE%97%E5%AD%90)中的一个重要例子。
>
> 拉普拉斯算子出现描述许多物理现象的微分方程里。例如，常用于[波方程](https://zh.wikipedia.org/wiki/%E6%B3%A2%E6%96%B9%E7%A8%8B)的[数学模型](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B)、[热传导方程](https://zh.wikipedia.org/wiki/%E7%86%B1%E5%82%B3%E5%B0%8E%E6%96%B9%E7%A8%8B)、[流体力学](https://zh.wikipedia.org/wiki/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6)以及[亥姆霍兹方程](https://zh.wikipedia.org/wiki/%E4%BA%A5%E5%A7%86%E9%9C%8D%E5%85%B9%E6%96%B9%E7%A8%8B)。在[静电学](https://zh.wikipedia.org/wiki/%E9%9D%9C%E9%9B%BB%E5%AD%B8)中，[拉普拉斯方程](https://zh.wikipedia.org/wiki/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E6%96%B9%E7%A8%8B)和[泊松方程](https://zh.wikipedia.org/wiki/%E6%B3%8A%E6%9D%BE%E6%96%B9%E7%A8%8B)的应用随处可见。在[量子力学](https://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%B8)中，其代表[薛定谔方程](https://zh.wikipedia.org/wiki/%E8%96%9B%E4%B8%81%E6%A0%BC%E6%96%B9%E7%A8%8B%E5%BC%8F)中的[动能](https://zh.wikipedia.org/wiki/%E5%8B%95%E8%83%BD)项。
>
> 拉普拉斯算子是最简单的[椭圆算子](https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E7%AE%97%E5%AD%90)，并且拉普拉斯算子是[霍奇理论](https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A5%87%E7%90%86%E8%AB%96)的核心，并且是[德拉姆上同调](https://zh.wikipedia.org/wiki/%E5%BE%B7%E6%8B%89%E5%A7%86%E4%B8%8A%E5%90%8C%E8%B0%83)的结果。在[图像处理](https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86)和[计算机视觉](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89)中，拉普拉斯算子已经被用于诸如[斑点检测](https://zh.wikipedia.org/w/index.php?title=%E6%96%91%E7%82%B9%E6%A3%80%E6%B5%8B&action=edit&redlink=1)和[边缘检测](https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B)等的各种任务。

Laplacian 使用了图像梯度，它内部的代码调用了 Sobel 算子。让一幅图像减去它的 Laplacian 算子可以增强对比度。

```c++

void cv::Laplacian	(	InputArray 	src,
						OutputArray 	dst,
						int 	ddepth,
						int 	ksize = 1,
						double 	scale = 1,
						double 	delta = 0,
						int 	borderType = BORDER_DEFAULT 
)	
```

- src: 源图像，Mat 类型，需要为**单通道 8 位图像**
- dst: 输出图像，尺寸和类型需要与 src 相同
- ddepth: 输出图像深度
- ksize: 用于计算二阶大数的滤波器的孔径尺寸，大小必须正奇数，默认值为 1
- scale: 计算拉普拉斯值的时候可选的比例因子，默认值为 1
- delta: 在结果存入输出图像全可选的 delta 值，默认值为 0
- borderType: 推断图像外包部像素的某种边界模式，一般用默认的即可

注：Laplacian() 函数使用  sobel 运算，加上 sobel 算子运算出图像 dx 和 dy，来得到载入图像的拉普拉斯变换的结果。

```c++
//---------------【边缘检测】----------------
// 描述：laplacian 函数用法示例
//------------------------------------------
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>

int main()
{
    cv::Mat src, src_gray, dst, abs_dst;

    // 载入原图像
    src = cv::imread("images/3.jpg", cv::IMREAD_COLOR);;
    cv::imshow("【原图】", src);

    // 使用高斯滤波降噪
    cv::GaussianBlur(src, src, cv::Size(3, 3), 0, 0, cv::BORDER_DEFAULT);

    // 转换为灰度图
    cv::cvtColor(src, src_gray, cv::COLOR_BGR2GRAY);

    // 使用 Laplacian 函数
    cv::Laplacian(src_gray, dst, CV_16S, 3, 1, 0, cv::BORDER_DEFAULT);

    //【6】计算绝对值，并将结果转换成8位
	convertScaleAbs( dst, abs_dst );

	//【7】显示效果图
	cv::imshow( "【效果图】图像Laplace变换", abs_dst );

	cv::waitKey(0); 

    return 0;
}
```